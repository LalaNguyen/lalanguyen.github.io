---
title: How ECALL/OCALL works in SGX
date: 2018-12-18 03:54:32 +0000
layout: post
undefined: 2018-12-18 00:00:00 +0000
categories: []

---
ecall in App.cpp will make another call to ecall in Enclave_u.c, which is generated by sgxedger tool

The edger generates an ocall table that holds function pointer to every ocall function we define in App.cpp

The edger also generates stuff code to make sgx__ecall, which takes enclave__id,

The sgx_ecall is an sgx interface exposed by SGX SDK to invoke SGX service. sgxecall is defined in the psw/urts/routine.cpp where it further invokes _sgx__ecall.

The  sgx_ecall picks an enclave with the corresponding eid from the enclave pool, and makes ecall using the enclave's eid. Input to the ecall includes proc/ocalltable and the marshalling structure. The function ends with doecall that receives function idx, ocall_ table, marshalling structure and trusted thread

the do_ecall makes call to enterenclave, which is the definition of __morestack assembly function_

__morestack is locates in the enter_enclave.S. It prepares necessary procedure and execute ENCLU\[ENTER\]. At this point, the control flow is transfer to the enclave at enclaveentry located in sdk/trts/linux/trts_pic.s

The ocall table is not used during the enclave transition. The enclave_entry performs several preparation before passing the call to enterenclave in trts__nsp.cpp . The function works like a dispatcher:

* if the function index >= 0 while cssa == 0, they are ecalls. The dispatcher launches do_ecall
* If the index is -2 while cssa == 0, then this indicates a return from an ocall.
* if the index is -3 while cssa == 1, then this is a return to enclave after exception

The do_ecall is located under sdk/trts/trts_ecall.cpp.

which will call the function trts_ecall co-located in the same file. This function retrieves the function address based on the function index via getfuncaddr and pass the marshalling structure to the ecall. Note that ecall table is also generated by the sgxedger tool to make sure that the index are consistent between trusted and untrusted code. As a developer, we do not need to manually indicate the index to an ecall When we write an ecall function inside Enclave folder, the sgxedger tool automatically generates API calls with associate index on the Enclave__u.c file

Similarly, on the reverse direction, we have sgx_ocall that receives an function index to be called by the enclave, and the marshalling structure

The sgx_call call backs to do_ocall which is also defined in the __morestack in the trusted world, the __morestack is a wrap function to the real do_ocall_

The do_ocall saves registers on stacks and calls EEXIT, which returns control back to the address follow EENTER in the __morestack version of untrusted code. The stack___sticker prepares something and call the sgx_ocall

The sgx_ocall located in the urts/routine.cpp of the untrusted code, the passed thread information is used to get the enclave instance, and we invoke the ocall

the enclave->ocall calls the do__ocall located in the sig__handler.cpp

Note that the parameter passes to the do_ocall function pointer points to the address of the function located in the ocall_table.

Inside do__ocall in the sig__handler.cpp:

    # In SDK psw/urts/linux/sig_handler.cpp
    int do_ocall(const bridge_fn_t bridge, void *marshalled_structure)
    {
    	int error = SGX_ERROR_UNEXPECTED;
        error = bridge(marshalled_structure);
        return error;
    }
    
    # The address of bridge is the function declared in Enclave_u.c generated 
    # by sgxedger tool. In this example, it is our defined function ocall_print_string
    static sgx_status_t SGX_CDECL Enclave_ocall_print_string(void *pms)
    {
    	ms_ocall_print_string_t* ms = SGX_CAST(ms_ocall_print_string_t*,pms);
        ocall_print_string(ms->ms_str); /* the ocall we write in App.cpp*/
        return SGX_SUCCESS;
    }