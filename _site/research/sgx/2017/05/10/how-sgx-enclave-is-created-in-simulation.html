<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>How SGX Enclave is Created in Simulation</title>
  <meta name="description" content="Objective The objective is to understand how an sgx enclave is created in theory and in practice (i.e., simulation mode).">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/research/sgx/2017/05/10/how-sgx-enclave-is-created-in-simulation.html">
  <link rel="alternate" type="application/rss+xml" title="Your awesome title" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">Your awesome title</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">How SGX Enclave is Created in Simulation</h1>
    <p class="post-meta">
      <time datetime="2017-05-10T11:40:55+08:00" itemprop="datePublished">
        
        May 10, 2017
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="objective">Objective</h2>
<p>The objective is to understand how an sgx enclave is created in theory and in practice (i.e., simulation mode).</p>

<h2 id="documentation">Documentation</h2>
<ol>
  <li><a href="https://eprint.iacr.org/2016/086.pdf">Intel SGX Explained - Page 63</a></li>
  <li><a href="https://download.01.org/intel-sgx/linux-1.8/docs/Intel_SGX_SDK_Installation_Guide_Linux_1.8_Open_Source.pdf">Intel SGX SDK Developer Reference for Linux 1.8</a></li>
  <li><a href="https://insujang.github.io/2017-04-14/intel-sgx-sdk-functions-for-enclave-creation/">Intel SGX SDK Functions for Enclave Creation</a></li>
  <li><a href="https://software.intel.com/sites/default/files/managed/48/88/329298-002.pdf">Intel Programming Reference</a></li>
  <li><a href="http://man7.org/linux/man-pages/man2/mmap.2.html">Linux’s mmap</a></li>
</ol>

<h2 id="theory">Theory</h2>

<p>An enclave is born when the system software issues the ECREATE instruction, which turns a free EPC page into the SECS for the new enclave. To understand ECREATE, we need to understand SECS, PAGEINFO, and EPCPAGE structure.</p>

<h3 id="secs--pageinfo">SECS &amp; PAGEINFO</h3>
<p>According to <a href="https://software.intel.com/sites/default/files/managed/48/88/329298-002.pdf">[4]</a>, the SECS is a data structure with 4K-Bytes alignment:
<img src="http://localhost:4000/images/SECS1.png" alt="My helpful screenshot" />
<img src="http://localhost:4000/images/SECS2.png" alt="My helpful screenshot" /></p>

<p>The SECS has the following properties:</p>
<blockquote>
  <p>There is one SECS for each enclave. The SECS contains meta-data which is used by the hardware to protect the enclave. Included in the SECS is a field which stores the enclave build measurement value. This field, MRENCLAVE, is initialized by the ECREATE instruction and updated by every EADD and EEXTEND. It is locked by EINIT. The SECS cannot be accessed by software.</p>
</blockquote>

<p>So SECS cannot be accessed by system softwares (OS/hypervisor). We focus on two important fields:</p>
<ul>
  <li><code class="highlighter-rouge">MRENCLAVE</code> is a unique hash for an enclave. This field is initialized by ECREATE and updated by <code class="highlighter-rouge">EADD</code> and <code class="highlighter-rouge">EEXTEND</code>, and</li>
  <li><code class="highlighter-rouge">MRSIGNER</code> is a proof of enclave’s ownership</li>
</ul>

<p><code class="highlighter-rouge">PAGEINFO</code> is an architectural data structure that is used as a parameter to the EPC-management instructions. It requires 32-Byte alignment.
<img src="http://localhost:4000/images/PAGEINFO.png" alt="My helpful screenshot" /></p>

<p>Unlike <code class="highlighter-rouge">SECS</code>, <code class="highlighter-rouge">PAGEINFO</code> can be accessed by the system software.<a href="https://eprint.iacr.org/2016/086.pdf">[1]</a></p>

<h3 id="ecreate">ECREATE</h3>
<p>System software specifies <code class="highlighter-rouge">base address</code> and <code class="highlighter-rouge">size of the enclave</code> in <code class="highlighter-rouge">unprotected SECS</code> outside of the EPC area. This address range is known as <code class="highlighter-rouge">ELRANGE</code>.</p>

<p>Following the <a href="https://software.intel.com/sites/default/files/managed/48/88/329298-002.pdf">[4]</a>, the ECREATE leaf instruction is responsible for:</p>
<ul>
  <li>Set up the initial environment</li>
  <li>ECREATE copies the <code class="highlighter-rouge">unprotected SECS</code> into EPC area, under newly created SECS page. This page is not part of the <code class="highlighter-rouge">ELRANGE</code> and shall not be mapped.</li>
  <li>Validate the information used to initialize protected SECS</li>
  <li>Set up fields in the protected SECS and mark the EPC page as <code class="highlighter-rouge">Valid</code></li>
  <li>Set up <code class="highlighter-rouge">INIT</code> attribute (sub-field of the <code class="highlighter-rouge">ATTRIBUTES</code> field in the enclave’s <code class="highlighter-rouge">SECS</code>) to <code class="highlighter-rouge">FALSE</code>. The enclave code cannot excute if this field is set to <code class="highlighter-rouge">FALSE</code>.</li>
</ul>

<p>This instruction requires ring-0 privileges and receives address of <code class="highlighter-rouge">PAGEINFO</code> struct and address of destination SECS page, which is an <code class="highlighter-rouge">EPCPAGE</code>, as an input.
<img src="http://localhost:4000/images/ECREATE.png" alt="My helpful screenshot" /></p>

<p>As for <code class="highlighter-rouge">ECREATE</code> instruction, <code class="highlighter-rouge">PAGEINFO</code> structure is prepared by the system software <a href="https://eprint.iacr.org/2016/086.pdf">[1]</a> with the <code class="highlighter-rouge">SECS</code> field unused <a href="https://software.intel.com/sites/default/files/managed/48/88/329298-002.pdf">[4]</a>. The <code class="highlighter-rouge">SRCPGE</code> of <code class="highlighter-rouge">PAGEINFO</code> contains the effective address of <code class="highlighter-rouge">the source/outside/unprotected SECS</code>. The RCX register is the effective address of the destination <code class="highlighter-rouge">SECS</code>. It is an address of an empty slot in the <code class="highlighter-rouge">EPC</code>.</p>

<h2 id="practice">Practice</h2>

<p>In this practice, I examine the code in <code class="highlighter-rouge">App.cpp</code> in <code class="highlighter-rouge">SampleEnclave</code> came along with sdk distribution. Skipping all the launch check, I observe the enclave is first created by <code class="highlighter-rouge">sgx_create_enclave</code></p>

<h3 id="sgx_create_enclave"><code class="highlighter-rouge">sgx_create_enclave</code></h3>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">SampleCode</span><span class="o">/</span><span class="n">SampleEnclave</span><span class="o">/</span><span class="n">App</span><span class="o">/</span><span class="n">App</span><span class="p">.</span><span class="n">cpp</span>

<span class="p">...</span>
<span class="cm">/* Step 2: call sgx_create_enclave to initialize an enclave instance */</span>
<span class="cm">/* Debug Support: set 2nd parameter to 1 */</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">sgx_create_enclave</span><span class="p">(</span><span class="n">ENCLAVE_FILENAME</span><span class="p">,</span> <span class="n">SGX_DEBUG_FLAG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">updated</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">global_eid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">...</span>

</code></pre>
</div>
<p>This function resides in the urts (unTruted Run-time System) library on <code class="highlighter-rouge">psw</code> directory. I put <code class="highlighter-rouge">prinf</code> and recompile the source codes to trace the flow</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">psw</span><span class="o">/</span><span class="n">urts</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">urts</span><span class="p">.</span><span class="n">cpp</span>


<span class="k">extern</span> <span class="s">"C"</span> <span class="n">sgx_status_t</span> <span class="n">sgx_create_enclave</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file_name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">debug</span><span class="p">,</span> <span class="n">sgx_launch_token_t</span> <span class="o">*</span><span class="n">launch_token</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">launch_token_updated</span><span class="p">,</span> <span class="n">sgx_enclave_id_t</span> <span class="o">*</span><span class="n">enclave_id</span><span class="p">,</span> <span class="n">sgx_misc_attribute_t</span> <span class="o">*</span><span class="n">misc_attr</span><span class="p">){</span>
<span class="p">...</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"-----sgx_create_enclave in urts.cpp-----</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">ret</span> <span class="o">=</span> <span class="n">_create_enclave</span><span class="p">(</span><span class="o">!!</span><span class="n">debug</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">launch_token</span><span class="p">,</span> <span class="n">launch_token_updated</span><span class="p">,</span> <span class="n">enclave_id</span><span class="p">,</span> <span class="n">misc_attr</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The function <code class="highlighter-rouge">_create_enclave</code> is defined in the header of <code class="highlighter-rouge">urts.cpp</code>, the <code class="highlighter-rouge">urts_com.h</code>:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">psw</span><span class="o">/</span><span class="n">urts</span><span class="o">/</span><span class="n">urts_com</span><span class="p">.</span><span class="n">h</span>

<span class="n">sgx_status_t</span> <span class="n">_create_enclave</span><span class="p">(</span><span class="k">const</span> <span class="kt">bool</span> <span class="n">debug</span><span class="p">,</span> <span class="n">se_file_handle_t</span> <span class="n">pfile</span><span class="p">,</span> <span class="n">se_file_t</span><span class="o">&amp;</span> <span class="n">file</span><span class="p">,</span> <span class="n">le_prd_css_file_t</span> <span class="o">*</span><span class="n">prd_css_file</span><span class="p">,</span> <span class="n">sgx_launch_token_t</span> <span class="o">*</span><span class="n">launch</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">launch_updated</span><span class="p">,</span> <span class="n">sgx_enclave_id_t</span> <span class="o">*</span><span class="n">enclave_id</span><span class="p">,</span> <span class="n">sgx_misc_attribute_t</span> <span class="o">*</span><span class="n">misc_attr</span><span class="p">){</span>
  <span class="c1">// Some codes with parser, I am not sure about the parser
</span>  <span class="c1">// Need to set the whole misc_attr instead of just secs_attr.
</span>  <span class="k">do</span> <span class="p">{</span>
      <span class="n">ret</span> <span class="o">=</span> <span class="n">__create_enclave</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">mh</span><span class="o">-&gt;</span><span class="n">base_addr</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="n">prd_css_file</span><span class="p">,</span> <span class="n">enclave_id</span><span class="p">,</span>
                             <span class="n">misc_attr</span><span class="p">);</span>
      <span class="c1">//SGX_ERROR_ENCLAVE_LOST caused by initializing enclave while power transition occurs
</span>  <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="n">SGX_ERROR_ENCLAVE_LOST</span> <span class="o">==</span> <span class="n">ret</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The <code class="highlighter-rouge">metadata</code> we pass to __create_enclave is actually not documented, but the code can be founded in <code class="highlighter-rouge">metadata.h</code>. Similarly, <code class="highlighter-rouge">enclave_css_t</code> holds information to compute enclave signature (i.e., <code class="highlighter-rouge">MRENCLAVE</code> and <code class="highlighter-rouge">MRSIGNER</code>), which can be founded in <code class="highlighter-rouge">arch.h</code></p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">common</span><span class="o">/</span><span class="n">inc</span><span class="o">/</span><span class="n">internal</span><span class="o">/</span><span class="n">metadata</span><span class="p">.</span><span class="n">h</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_metadata_t</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span>            <span class="n">magic_num</span><span class="p">;</span>             <span class="cm">/* The magic number identifying the file as a signed enclave image */</span>
    <span class="kt">uint64_t</span>            <span class="n">version</span><span class="p">;</span>               <span class="cm">/* The metadata version */</span>
    <span class="kt">uint32_t</span>            <span class="n">size</span><span class="p">;</span>                  <span class="cm">/* The size of this structure */</span>
    <span class="kt">uint32_t</span>            <span class="n">tcs_policy</span><span class="p">;</span>            <span class="cm">/* TCS management policy */</span>
    <span class="kt">uint32_t</span>            <span class="n">ssa_frame_size</span><span class="p">;</span>        <span class="cm">/* The size of SSA frame in page */</span>
    <span class="kt">uint32_t</span>            <span class="n">max_save_buffer_size</span><span class="p">;</span>  <span class="cm">/* Max buffer size is 2632 */</span>
    <span class="kt">uint32_t</span>            <span class="n">desired_misc_select</span><span class="p">;</span>
    <span class="kt">uint32_t</span>            <span class="n">reserved</span><span class="p">;</span>
    <span class="kt">uint64_t</span>            <span class="n">enclave_size</span><span class="p">;</span>          <span class="cm">/* enclave virtual size */</span>
    <span class="n">sgx_attributes_t</span>    <span class="n">attributes</span><span class="p">;</span>            <span class="cm">/* XFeatureMask to be set in SECS. */</span>
    <span class="n">enclave_css_t</span>       <span class="n">enclave_css</span><span class="p">;</span>           <span class="cm">/* The enclave signature */</span>
    <span class="n">data_directory_t</span>    <span class="n">dirs</span><span class="p">[</span><span class="n">DIR_NUM</span><span class="p">];</span>
    <span class="kt">uint8_t</span>             <span class="n">data</span><span class="p">[</span><span class="mi">2208</span><span class="p">];</span>
<span class="p">}</span><span class="n">metadata_t</span><span class="p">;</span>
</code></pre>
</div>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="cm">/****************************************************************************
* Definitions for enclave signature
****************************************************************************/</span>
<span class="cp">#define SE_KEY_SIZE         384         </span><span class="cm">/* in bytes */</span><span class="cp">
#define SE_EXPONENT_SIZE    4           </span><span class="cm">/* RSA public key exponent size in bytes */</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_css_header_t</span> <span class="p">{</span>        <span class="cm">/* 128 bytes */</span>
    <span class="kt">uint8_t</span>  <span class="n">header</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>                <span class="cm">/* (0) must be (06000000E100000000000100H) */</span>
    <span class="kt">uint32_t</span> <span class="n">type</span><span class="p">;</span>                      <span class="cm">/* (12) bit 31: 0 = prod, 1 = debug; Bit 30-0: Must be zero */</span>
    <span class="kt">uint32_t</span> <span class="n">module_vendor</span><span class="p">;</span>             <span class="cm">/* (16) Intel=0x8086, ISV=0x0000 */</span>
    <span class="kt">uint32_t</span> <span class="n">date</span><span class="p">;</span>                      <span class="cm">/* (20) build date as yyyymmdd */</span>
    <span class="kt">uint8_t</span>  <span class="n">header2</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>               <span class="cm">/* (24) must be (01010000600000006000000001000000H) */</span>
    <span class="kt">uint32_t</span> <span class="n">hw_version</span><span class="p">;</span>                <span class="cm">/* (40) For Launch Enclaves: HWVERSION != 0. Others, HWVERSION = 0 */</span>
    <span class="kt">uint8_t</span>  <span class="n">reserved</span><span class="p">[</span><span class="mi">84</span><span class="p">];</span>              <span class="cm">/* (44) Must be 0 */</span>
<span class="p">}</span> <span class="n">css_header_t</span><span class="p">;</span>
<span class="n">se_static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">css_header_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">128</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_css_key_t</span> <span class="p">{</span>           <span class="cm">/* 772 bytes */</span>
    <span class="kt">uint8_t</span> <span class="n">modulus</span><span class="p">[</span><span class="n">SE_KEY_SIZE</span><span class="p">];</span>       <span class="cm">/* (128) Module Public Key (keylength=3072 bits) */</span>
    <span class="kt">uint8_t</span> <span class="n">exponent</span><span class="p">[</span><span class="n">SE_EXPONENT_SIZE</span><span class="p">];</span> <span class="cm">/* (512) RSA Exponent = 3 */</span>
    <span class="kt">uint8_t</span> <span class="n">signature</span><span class="p">[</span><span class="n">SE_KEY_SIZE</span><span class="p">];</span>     <span class="cm">/* (516) Signature over Header and Body */</span>
<span class="p">}</span> <span class="n">css_key_t</span><span class="p">;</span>
<span class="n">se_static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">css_key_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">772</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_css_body_t</span> <span class="p">{</span>            <span class="cm">/* 128 bytes */</span>
    <span class="n">sgx_misc_select_t</span>   <span class="n">misc_select</span><span class="p">;</span>    <span class="cm">/* (900) The MISCSELECT that must be set */</span>
    <span class="n">sgx_misc_select_t</span>   <span class="n">misc_mask</span><span class="p">;</span>      <span class="cm">/* (904) Mask of MISCSELECT to enforce */</span>
    <span class="kt">uint8_t</span>             <span class="n">reserved</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>   <span class="cm">/* (908) Reserved. Must be 0. */</span>
    <span class="n">sgx_attributes_t</span>    <span class="n">attributes</span><span class="p">;</span>     <span class="cm">/* (928) Enclave Attributes that must be set */</span>
    <span class="n">sgx_attributes_t</span>    <span class="n">attribute_mask</span><span class="p">;</span> <span class="cm">/* (944) Mask of Attributes to Enforce */</span>
    <span class="n">sgx_measurement_t</span>   <span class="n">enclave_hash</span><span class="p">;</span>   <span class="cm">/* (960) MRENCLAVE - (32 bytes) */</span>
    <span class="kt">uint8_t</span>             <span class="n">reserved2</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>  <span class="cm">/* (992) Must be 0 */</span>
    <span class="kt">uint16_t</span>            <span class="n">isv_prod_id</span><span class="p">;</span>    <span class="cm">/* (1024) ISV assigned Product ID */</span>
    <span class="kt">uint16_t</span>            <span class="n">isv_svn</span><span class="p">;</span>        <span class="cm">/* (1026) ISV assigned SVN */</span>
<span class="p">}</span> <span class="n">css_body_t</span><span class="p">;</span>
<span class="n">se_static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">css_body_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">128</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_css_buffer_t</span> <span class="p">{</span>         <span class="cm">/* 780 bytes */</span>
    <span class="kt">uint8_t</span>  <span class="n">reserved</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>              <span class="cm">/* (1028) Must be 0 */</span>
    <span class="kt">uint8_t</span>  <span class="n">q1</span><span class="p">[</span><span class="n">SE_KEY_SIZE</span><span class="p">];</span>           <span class="cm">/* (1040) Q1 value for RSA Signature Verification */</span>
    <span class="kt">uint8_t</span>  <span class="n">q2</span><span class="p">[</span><span class="n">SE_KEY_SIZE</span><span class="p">];</span>           <span class="cm">/* (1424) Q2 value for RSA Signature Verification */</span>
<span class="p">}</span> <span class="n">css_buffer_t</span><span class="p">;</span>
<span class="n">se_static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">css_buffer_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">780</span><span class="p">);</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_enclave_css_t</span> <span class="p">{</span>        <span class="cm">/* 1808 bytes */</span>
    <span class="n">css_header_t</span>    <span class="n">header</span><span class="p">;</span>             <span class="cm">/* (0) */</span>
    <span class="n">css_key_t</span>       <span class="n">key</span><span class="p">;</span>                <span class="cm">/* (128) */</span>
    <span class="n">css_body_t</span>      <span class="n">body</span><span class="p">;</span>               <span class="cm">/* (900) */</span>
    <span class="n">css_buffer_t</span>    <span class="n">buffer</span><span class="p">;</span>             <span class="cm">/* (1028) */</span>
<span class="p">}</span> <span class="n">enclave_css_t</span><span class="p">;</span>
</code></pre>
</div>

<p>The function <code class="highlighter-rouge">__create_enclave</code> is defined within the same file header <code class="highlighter-rouge">urts_com.h</code>:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">psw</span><span class="o">/</span><span class="n">urts</span><span class="o">/</span><span class="n">urts_com</span><span class="p">.</span><span class="n">h</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__create_enclave</span><span class="p">(</span><span class="n">BinParser</span> <span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">base_addr</span><span class="p">,</span> <span class="k">const</span> <span class="n">metadata_t</span> <span class="o">*</span><span class="n">metadata</span><span class="p">,</span> <span class="n">se_file_t</span><span class="o">&amp;</span> <span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">debug</span><span class="p">,</span> <span class="n">SGXLaunchToken</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="n">le_prd_css_file_t</span> <span class="o">*</span><span class="n">prd_css_file</span><span class="p">,</span> <span class="n">sgx_enclave_id_t</span> <span class="o">*</span><span class="n">enclave_id</span><span class="p">,</span> <span class="n">sgx_misc_attribute_t</span> <span class="o">*</span><span class="n">misc_attr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// The "parser" will be registered into "loader" and "loader" will be registered into "enclave".
</span>    <span class="c1">// After enclave is created, "parser" and "loader" are not needed any more.
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"-----create_enclave in urts_com.h-----</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">loader</span><span class="p">.</span><span class="n">load_enclave_ex</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">prd_css_file</span><span class="p">,</span> <span class="n">misc_attr</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The function <code class="highlighter-rouge">load_enclave_ex</code> is defined in <code class="highlighter-rouge">loader.cpp</code>, which in-turn call the <code class="highlighter-rouge">load_enclave</code></p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">psw</span><span class="o">/</span><span class="n">urts</span><span class="o">/</span><span class="n">loader</span><span class="p">.</span><span class="n">cpp</span>

<span class="kt">int</span> <span class="n">CLoader</span><span class="o">::</span><span class="n">load_enclave_ex</span><span class="p">(</span><span class="n">SGXLaunchToken</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">debug</span><span class="p">,</span> <span class="k">const</span> <span class="n">metadata_t</span> <span class="o">*</span><span class="n">metadata</span><span class="p">,</span> <span class="n">le_prd_css_file_t</span> <span class="o">*</span><span class="n">prd_css_file</span><span class="p">,</span> <span class="n">sgx_misc_attribute_t</span> <span class="o">*</span><span class="n">misc_attr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
<span class="k">while</span> <span class="p">(</span><span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">load_enclave</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">prd_css_file</span><span class="p">,</span> <span class="n">misc_attr</span><span class="p">);</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//If CreateEnclave failed due to power transition, we retry it.
</span>    <span class="k">case</span> <span class="n">SGX_ERROR_ENCLAVE_LOST</span><span class="p">:</span>     <span class="c1">//caused by loading enclave while power transition occurs
</span>        <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The function <code class="highlighter-rouge">load_enclave</code> defined in <code class="highlighter-rouge">loader.cpp</code> does a couple of interesting things:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">psw</span><span class="o">/</span><span class="n">urts</span><span class="o">/</span><span class="n">loader</span><span class="p">.</span><span class="n">cpp</span>

<span class="kt">int</span> <span class="n">CLoader</span><span class="o">::</span><span class="n">load_enclave</span><span class="p">(</span><span class="n">SGXLaunchToken</span> <span class="o">*</span><span class="n">lc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">debug</span><span class="p">,</span> <span class="k">const</span> <span class="n">metadata_t</span> <span class="o">*</span><span class="n">metadata</span><span class="p">,</span> <span class="n">le_prd_css_file_t</span> <span class="o">*</span><span class="n">prd_css_file</span><span class="p">,</span> <span class="n">sgx_misc_attribute_t</span> <span class="o">*</span><span class="n">misc_attr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="n">required_attr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">metadata</span><span class="o">-&gt;</span><span class="n">attributes</span><span class="p">;</span>
  <span class="n">enclave_css</span>   <span class="o">=</span> <span class="o">&amp;</span><span class="n">metadata</span><span class="o">-&gt;</span><span class="n">enclave_css</span><span class="p">;</span>
  <span class="n">secs_attr</span>     <span class="o">=</span> <span class="o">&amp;</span><span class="n">sgx_misc_attr</span><span class="o">-&gt;</span><span class="n">secs_attr</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">validate_metadata</span><span class="p">();</span>
  <span class="p">...</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">get_enclave_creator</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">get_misc_attr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgx_misc_attr</span><span class="p">,</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">metadata_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">m_metadata</span><span class="p">),</span> <span class="n">lc</span><span class="p">,</span> <span class="n">debug</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">ret</span> <span class="o">=</span> <span class="n">build_image</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sgx_misc_attr</span><span class="p">.</span><span class="n">secs_attr</span><span class="p">,</span> <span class="n">prd_css_file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sgx_misc_attr</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>
<p>First, it validates the metadata struct. Second, it calls <code class="highlighter-rouge">get_enclave_creator</code>, either response with SIM or HW constructor. In our case, the <code class="highlighter-rouge">get_enclave_creator</code> returns an instance from <code class="highlighter-rouge">enclave_creator_sim.cpp</code>. In brief, <code class="highlighter-rouge">get_misc_attr</code> validates information consistency between (1) <code class="highlighter-rouge">sgx_misc_attr</code> and <code class="highlighter-rouge">m_metadata</code>, and (2) <code class="highlighter-rouge">sgx_misc_attr</code> with launch token <code class="highlighter-rouge">lc</code>:</p>
<ul>
  <li>FP/SSE are must-have attributes</li>
  <li>secs attributes.xfrm (secs_attr) does NOT match signature attributes.xfrm (enclave_css)</li>
  <li>secs attributes.flag (secs_attr) does NOT match signature attributes.flag (enclave_css)</li>
  <li>secs attributes does NOT match launch token attributes</li>
</ul>

<p>Once the metadata is verified against the <code class="highlighter-rouge">secs_attr</code> in <code class="highlighter-rouge">sgx_misc_attr</code>, the system software begins the enclave building process with only <code class="highlighter-rouge">sgx_misc_attr</code>. The <code class="highlighter-rouge">build_image</code> can be found in <code class="highlighter-rouge">loader.cpp</code></p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">psw</span><span class="o">/</span><span class="n">urts</span><span class="o">/</span><span class="n">loader</span><span class="p">.</span><span class="n">cpp</span>

<span class="kt">int</span> <span class="n">CLoader</span><span class="o">::</span><span class="n">build_image</span><span class="p">(</span><span class="n">SGXLaunchToken</span> <span class="o">*</span> <span class="k">const</span> <span class="n">lc</span><span class="p">,</span> <span class="n">sgx_attributes_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">secs_attr</span><span class="p">,</span> <span class="n">le_prd_css_file_t</span> <span class="o">*</span><span class="n">prd_css_file</span><span class="p">,</span> <span class="n">sgx_misc_attribute_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">misc_attr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">SGX_SUCCESS</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">build_secs</span><span class="p">(</span><span class="n">secs_attr</span><span class="p">,</span> <span class="n">misc_attr</span><span class="p">)))</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>
<p>The build_secs seems what we are interested in. Recall that during the ECREATE, the system software must prepare the unprotected SECS struct, which can be accessed through <code class="highlighter-rouge">PAGEINFO</code>. The <code class="highlighter-rouge">build_secs</code> is as follows:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">psw</span><span class="o">/</span><span class="n">urts</span><span class="o">/</span><span class="n">loader</span><span class="p">.</span><span class="n">cpp</span>

<span class="kt">int</span> <span class="n">CLoader</span><span class="o">::</span><span class="n">build_secs</span><span class="p">(</span><span class="n">sgx_attributes_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">secs_attr</span><span class="p">,</span> <span class="n">sgx_misc_attribute_t</span> <span class="o">*</span> <span class="k">const</span> <span class="n">misc_attr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_secs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">secs_t</span><span class="p">));</span> <span class="c1">//should set reversed field of secs as 0.
</span>    <span class="c1">//create secs structure.
</span>    <span class="n">m_secs</span><span class="p">.</span><span class="n">base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">//base is allocated by driver. set it as 0
</span>    <span class="c1">// Fill in size of enclave
</span>    <span class="n">m_secs</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">m_metadata</span><span class="o">-&gt;</span><span class="n">enclave_size</span><span class="p">;</span>
    <span class="c1">// Fill in MISC_SELECT
</span>    <span class="n">m_secs</span><span class="p">.</span><span class="n">misc_select</span> <span class="o">=</span> <span class="n">misc_attr</span><span class="o">-&gt;</span><span class="n">misc_select</span><span class="p">;</span>

    <span class="n">memcpy_s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_secs</span><span class="p">.</span><span class="n">attributes</span><span class="p">,</span>  <span class="k">sizeof</span><span class="p">(</span><span class="n">m_secs</span><span class="p">.</span><span class="n">attributes</span><span class="p">),</span> <span class="n">secs_attr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">m_secs</span><span class="p">.</span><span class="n">attributes</span><span class="p">));</span>
    <span class="n">m_secs</span><span class="p">.</span><span class="n">ssa_frame_size</span> <span class="o">=</span> <span class="n">m_metadata</span><span class="o">-&gt;</span><span class="n">ssa_frame_size</span><span class="p">;</span>

    <span class="n">EnclaveCreator</span> <span class="o">*</span><span class="n">enclave_creator</span> <span class="o">=</span> <span class="n">get_enclave_creator</span><span class="p">();</span>
    <span class="k">if</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">enclave_creator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">SGX_ERROR_UNEXPECTED</span><span class="p">;</span>
    <span class="c1">// Start address of the enclave is not determined until the next line is executed
</span>    <span class="n">SE_TRACE</span><span class="p">(</span><span class="n">SE_TRACE_NOTICE</span><span class="p">,</span> <span class="s">"enclave start address = %p, size = %x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">m_start_addr</span><span class="p">,</span> <span class="n">m_metadata</span><span class="o">-&gt;</span><span class="n">enclave_size</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">enclave_creator</span><span class="o">-&gt;</span><span class="n">create_enclave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_secs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_enclave_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m_start_addr</span><span class="p">,</span> <span class="n">is_ae</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m_metadata</span><span class="o">-&gt;</span><span class="n">enclave_css</span><span class="p">));</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>I input the line <code class="highlighter-rouge">SE_TRACE(SE_TRACE_NOTICE, "enclave start address = %p, size = %x\n", m_start_addr, m_metadata-&gt;enclave_size)</code> and the output is</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>build_secs /home/lalang/linux-sgx/psw/urts/loader.cpp:362] enclave start address <span class="o">=</span> <span class="o">(</span>nil<span class="o">)</span>, size <span class="o">=</span> 800000
</code></pre>
</div>
<p>So the size is computed, but the base address is not available yet. One we execute the next line, we obtain the following output:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code><span class="o">[</span>build_secs /home/lalang/linux-sgx/psw/urts/loader.cpp:366] enclave start address <span class="o">=</span> 0x7fe368971000, size <span class="o">=</span> 800000
</code></pre>
</div>
<p>This give us a hint that ECREATE is actually executed inside <code class="highlighter-rouge">create_enclave</code> of <code class="highlighter-rouge">loader.cpp</code>. As an instance of <code class="highlighter-rouge">EnclaveCreatorSim</code>, I look into <code class="highlighter-rouge">enclave_creator_sim.cpp</code>:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">sdk</span><span class="o">/</span><span class="n">simulation</span><span class="o">/</span><span class="n">urtssim</span><span class="o">/</span><span class="n">enclave_creator_sim</span><span class="p">.</span><span class="n">cpp</span>

<span class="kt">int</span> <span class="n">EnclaveCreatorSim</span><span class="o">::</span><span class="n">create_enclave</span><span class="p">(</span><span class="n">secs_t</span> <span class="o">*</span><span class="n">secs</span><span class="p">,</span> <span class="n">sgx_enclave_id_t</span> <span class="o">*</span><span class="n">enclave_id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">start_addr</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ae</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UNUSED</span><span class="p">(</span><span class="n">ae</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">::</span><span class="n">create_enclave</span><span class="p">(</span><span class="n">secs</span><span class="p">,</span> <span class="n">enclave_id</span><span class="p">,</span> <span class="n">start_addr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Since this is simulation, <code class="highlighter-rouge">ae</code> is not used, and the control flow is forwarded to <code class="highlighter-rouge">::create_enclave(secs, enclave_id, start_addr)</code>. In C++, this resolves to top-level <code class="highlighter-rouge">create_enclave</code> function, located in <code class="highlighter-rouge">driver_api.cpp</code></p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">sdk</span><span class="o">/</span><span class="n">simulation</span><span class="o">/</span><span class="n">driver_api</span><span class="o">/</span><span class="n">driver_api</span><span class="p">.</span><span class="n">cpp</span>

<span class="cm">/* Allocate linear address space. */</span>
<span class="kt">int</span> <span class="n">create_enclave</span><span class="p">(</span><span class="n">secs_t</span>           <span class="o">*</span><span class="n">secs</span><span class="p">,</span>
                   <span class="n">sgx_enclave_id_t</span> <span class="o">*</span><span class="n">enclave_id</span><span class="p">,</span>
                   <span class="kt">void</span>             <span class="o">**</span><span class="n">start_addr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">CEnclaveSim</span>   <span class="o">*</span><span class="n">ce</span><span class="p">;</span>
    <span class="n">sec_info_t</span>    <span class="n">sinfo</span><span class="p">;</span>
    <span class="n">page_info_t</span>   <span class="n">pinfo</span><span class="p">;</span>
    <span class="n">BUG_ON</span><span class="p">(</span><span class="n">secs</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">SGX_ERROR_UNEXPECTED</span><span class="p">);</span>
    <span class="n">BUG_ON</span><span class="p">(</span><span class="n">enclave_id</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">SGX_ERROR_UNEXPECTED</span><span class="p">);</span>
    <span class="n">BUG_ON</span><span class="p">(</span><span class="n">start_addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">SGX_ERROR_UNEXPECTED</span><span class="p">);</span>
    <span class="c1">// clear SECINFO
</span>    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sinfo</span><span class="p">));</span>
    <span class="n">sinfo</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">SI_FLAGS_SECS</span><span class="p">;</span> <span class="c1">// Assign FLAGS to #define SI_FLAG_SECS (0x00&lt;&lt;0x8) /* SECS */ &lt;--- PT_SECS left shift by 8 bits
</span>
    <span class="c1">// clear PAGEINFO
</span>    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pinfo</span><span class="p">));</span>
    <span class="n">pinfo</span><span class="p">.</span><span class="n">src_page</span> <span class="o">=</span> <span class="n">secs</span><span class="p">;</span> <span class="c1">// Assign SRCPGE to unprotected SECS
</span>    <span class="n">pinfo</span><span class="p">.</span><span class="n">sec_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sinfo</span><span class="p">;</span>  <span class="c1">//Assign SECINFO that describe the state of the enclave page
</span>
    <span class="c1">// let the destination EPCPage filled by hardware since this is simulation, we can only observe PAGEINFO as an input
</span>    <span class="n">ce</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">CEnclaveSim</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">DoECREATE_SW</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pinfo</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ce</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SE_TRACE</span><span class="p">(</span><span class="n">SE_TRACE_DEBUG</span><span class="p">,</span> <span class="s">"out of memory.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">SGX_ERROR_OUT_OF_MEMORY</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">*</span><span class="n">start_addr</span> <span class="o">=</span> <span class="n">ce</span><span class="o">-&gt;</span><span class="n">get_secs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
    <span class="o">*</span><span class="n">enclave_id</span> <span class="o">=</span> <span class="n">ce</span><span class="o">-&gt;</span><span class="n">get_enclave_id</span><span class="p">();</span>
    <span class="n">secs</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="o">*</span><span class="n">start_addr</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">SGX_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>
<p>Trace through the header, we see that <code class="highlighter-rouge">DoECREATE_SW</code> is a macro defined in <code class="highlighter-rouge">sw_emu.h</code></p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux_sgx</span><span class="o">/</span><span class="n">sdk</span><span class="o">/</span><span class="n">simulation</span><span class="o">/</span><span class="n">assembly</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">sw_emu</span><span class="p">.</span><span class="n">h</span>

<span class="cm">/* This macro is used to generate simulation functions like:
 * DoECREATE_SW, DoEADD_SW, ...
*/</span>
<span class="p">.</span><span class="n">macro</span> <span class="n">DoSW</span> <span class="n">inst</span>
<span class="n">DECLARE_LOCAL_FUNC</span> <span class="n">Do</span><span class="err">\</span><span class="p">()</span><span class="err">\</span><span class="n">inst</span><span class="err">\</span><span class="p">()</span><span class="n">_SW</span>
    <span class="n">SE_PROLOG</span>
    <span class="err">\</span><span class="n">inst</span><span class="err">\</span><span class="p">()</span><span class="n">_SW</span>
    <span class="n">SE_EPILOG</span>
<span class="p">.</span><span class="n">endm</span>

</code></pre>
</div>
<p>which means <code class="highlighter-rouge">Do'ECREATE'_SW</code> is declared as <code class="highlighter-rouge">'ECREATE'_SW</code>. And <code class="highlighter-rouge">ECREATE_SW</code> is also declared right above.</p>

<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux_sgx</span><span class="o">/</span><span class="n">sdk</span><span class="o">/</span><span class="n">simulation</span><span class="o">/</span><span class="n">assembly</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">sw_emu</span><span class="p">.</span><span class="n">h</span>

<span class="p">.</span><span class="n">macro</span> <span class="n">ECREATE_SW</span>
    <span class="n">SE0_SW</span> <span class="n">SE_ECREATE</span>
<span class="p">.</span><span class="n">endm</span>

<span class="p">.</span><span class="n">macro</span> <span class="n">EADD_SW</span>
    <span class="n">SE0_SW</span> <span class="n">SE_EADD</span>
<span class="p">.</span><span class="n">endm</span>

<span class="p">.</span><span class="n">macro</span> <span class="n">EINIT_SW</span>
    <span class="n">SE0_SW</span> <span class="n">SE_EINIT</span>
<span class="p">.</span><span class="n">endm</span>

<span class="p">.</span><span class="n">macro</span> <span class="n">EREMOVE_SW</span>
    <span class="n">SE0_SW</span> <span class="n">SE_EREMOVE</span>
<span class="p">.</span><span class="n">endm</span>
</code></pre>
</div>

<p>Hence, <code class="highlighter-rouge">DoECREATE_SW()</code><code class="highlighter-rouge"> actually calls </code>SE_ECREATE()`` function, defined in <code class="highlighter-rouge">u_instructions.cpp</code>.</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux_sgx</span><span class="o">/</span><span class="n">sdk</span><span class="o">/</span><span class="n">simulation</span><span class="o">/</span><span class="n">uinst</span><span class="o">/</span><span class="n">u_instructions</span>

<span class="kt">uintptr_t</span> <span class="n">_SE0</span><span class="p">(</span><span class="kt">uintptr_t</span> <span class="n">xax</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">xbx</span><span class="p">,</span>
               <span class="kt">uintptr_t</span> <span class="n">xcx</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">xdx</span><span class="p">,</span>
               <span class="kt">uintptr_t</span> <span class="n">xsi</span><span class="p">,</span> <span class="kt">uintptr_t</span> <span class="n">xdi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UNUSED</span><span class="p">(</span><span class="n">xsi</span><span class="p">),</span> <span class="n">UNUSED</span><span class="p">(</span><span class="n">xdi</span><span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">xax</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">SE_ECREATE</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_ECREATE</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">page_info_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">xbx</span><span class="p">));</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Finally, we arrive at the simulated <code class="highlighter-rouge">ECREATE</code>:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux_sgx</span><span class="o">/</span><span class="n">sdk</span><span class="o">/</span><span class="n">simulation</span><span class="o">/</span><span class="n">uinst</span><span class="o">/</span><span class="n">u_instructions</span>

<span class="c1">// Returns the pointer to the Enclave instance on success.
</span><span class="kt">uintptr_t</span> <span class="n">_ECREATE</span><span class="p">(</span><span class="n">page_info_t</span><span class="o">*</span> <span class="n">pi</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Address of unprotected SECS
</span>    <span class="n">secs_t</span><span class="o">*</span> <span class="n">secs</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">secs_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">src_page</span><span class="p">);</span>

    <span class="c1">// Enclave size must be at least 2 pages and a power of 2.
</span>    <span class="n">GP_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_power_of_two</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">secs</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
    <span class="n">GP_ON</span><span class="p">(</span><span class="n">secs</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">SE_PAGE_SIZE</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>

    <span class="c1">// Associate a secs without base address to an enclave
</span>    <span class="n">CEnclaveSim</span><span class="o">*</span> <span class="n">ce</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CEnclaveSim</span><span class="p">(</span><span class="n">secs</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span>   <span class="n">addr</span><span class="p">;</span>

    <span class="c1">// `ce' is not checked against NULL, since it is not
</span>    <span class="c1">// allocated with new(std::no_throw).
</span>    <span class="n">addr</span> <span class="o">=</span> <span class="n">se_virtual_alloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">secs</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">MEM_COMMIT</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">ce</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Mark all the memory inaccessible.
</span>    <span class="n">se_virtual_protect</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">secs</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">SGX_PROT_NONE</span><span class="p">);</span>
    <span class="c1">// Assign the base address in SECS to the beginning of protected region
</span>    <span class="n">ce</span><span class="o">-&gt;</span><span class="n">get_secs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">addr</span><span class="p">;</span>

    <span class="n">CEnclaveMngr</span><span class="o">::</span><span class="n">get_instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">ce</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ce</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The line <code class="highlighter-rouge">se_virtual_alloc</code> is interesting. We found it in <code class="highlighter-rouge">se_memory.c</code>. It returns a fixed region of memory upon successful:</p>
<div class="language-cpp highlighter-rouge"><pre class="highlight"><code><span class="n">linux</span><span class="o">-</span><span class="n">sgx</span><span class="o">/</span><span class="n">common</span><span class="o">/</span><span class="n">inc</span><span class="o">/</span><span class="n">internal</span><span class="o">/</span><span class="n">se_memory</span><span class="p">.</span><span class="n">c</span>

<span class="kt">void</span><span class="o">*</span> <span class="n">se_virtual_alloc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">address</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">type</span><span class="p">)</span>
<span class="cm">/*
Releases, decommits, or releases and decommits a region of pages within the virtual address space of the calling process.
@address:A pointer to the base address of the region of pages to be freed. If the dwFreeType parameter is MEM_RELEASE,
        this parameter must be the base address returned by the se_virtual_alloc function when the region of pages is reserved.
@size:	The size of the region of memory to be freed, in bytes.
@type:	Only MEM_RELEASE accepted
        MEM_RELEASE - releases the specified region of pages. After this operation, the pages are in the free state.
@return value:If the function succeeds, the return value is nonzero.If the function fails, the return value is zero.
*/</span>
<span class="p">{</span>
    <span class="n">UNUSED</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">pRet</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span>  <span class="n">MAP_ANONYMOUS</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">MAP_FAILED</span> <span class="o">==</span> <span class="n">pRet</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">pRet</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Upon succesful, mmap <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">[5]</a> returns a pointer to mapped area. The file descriptor <code class="highlighter-rouge">fd =-1</code> indicates that we do not map to file, but map directly to system’s memory.</p>

<p>In summary, we can neither observe the <code class="highlighter-rouge">ECREATE</code> copies page from unprotected SECS to protected SECS nor a page is allocated to unprotected SECS. Here is the summarized control flow we walked through above</p>

<p><img src="http://localhost:4000/images/simulation-ecreate.png" alt="My helpful screenshot" /></p>


  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Your awesome title
            
            </li>
            
            <li><a href="mailto:your-email@domain.com">your-email@domain.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/jekyll"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">jekyll</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/jekyllrb"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">jekyllrb</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
