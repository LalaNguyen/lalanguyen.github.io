---
layout: post
title:  "How EINIT works in Simulation Mode"
date:   2017-05-19 10:00:00 +0800
categories: research sgx
---
## Objective
The objective is to understand how an enclave is initialized and launched by an architectural enclave - the Launch Enclave (LE). I review this instruction in both theory and practice (i.e., Simulation Mode).

## Documentation
1. [Intel SGX Explained - Page 64] [sgx-explain]
2. [Intel SGX Programming Reference for Linux 1.8] [sgx-programming]
3. [Method and apparatus to provide secure application execution][sgx-patent]

## Theory

After enclave's code and data are loaded, `EINIT` is invoked to complete the enclave creation process. `EINIT` finalizes the enclave measurement to establish the (1) enclave entity and (2) sealing entity used by `EGETKEY` and `EREPORT` during `software attestation`. Until an `EINIT` is executed, the enclave is not permitted to execute any enclave code(i.e., entering enclave by executing EENTER).

A correct construction results in the cryptographic log `EINITTOKEN` matching the one built by enclave owner in `SIGSTRUCT`.

### SIGSTRUCT & EINITTOKEN

The SGX requires each enclave to have a certificate issued by author. Hence, SIGSTRUCT contains information about the enclave originated from enclave owner, and must be 4KB aligned. The complete layout of SIGSTRUCT is as follow:
![My helpful screenshot]({{site.url}}/images/SIGSTRUCT.png)

This structure is intended to be generated by the enclave building toolchain that has access to enclave's author RSA[[1]][sgx-explain].



Launch Enclave (LE) consumes a `SIGSTRUCT`, `negotiates with the License Authority in the cloud`[[3]][sgx-patent] to ensure that a developer has a correct SGX licensee. Launch Enclave generates a `EINIT token` which is used by the `EINIT` instruction to verify that the enclave is permit to run. Launch Enclave is undocumented, but it has its attributes marked in `EINIT token` as follows:
![My helpful screenshot]({{site.url}}/images/EINITTOKEN.png)

Note that `EINIT instruction` will only accept the `EINIT token` after the `Launch Enclave` uses the `License Key` to CMAC it. This ensures that the malicious OS cannot tamper with the `EINIT token`.

### Launch Enclave

While Launch Enclave is undocumented, Intel sheds light on brief functions of Launch Enclave in their patent [[3]][sgx-patent], where they call it `License Enclave`:

> Not all enclaves requires a permit. In order to ease development for enclaves, permits will be optional during the development and debugging phases. Non-debug enclaves always require a permit to launch.

>The License Enclave is designed to make decisions about enclave launching outside the scope of visibility for uCode. For example, uCode cannot evaluate whether an ISV's business arrangements with Intel allow for an additional enclave deployment. The License Enclave is designed to collect whatever material is necessary to make an assessment and either further approve the enclave launch, or veto it. The License Enclave is only required to support complex business arrangements, and is not necessary for Bulk Licenses such as the ability to launch the enclave on any platform as many times as is needed.

>The License Enclave is expected to be a system service. If a license indicates it needed further approval from the License Enclave, the chain of licenses and the enclave permit created by EMKPERMIT are passed to the License Enclave. The License Enclave then generates an approval request. The application then sends this approval request to the appropriate License Authority, which generates an approval notice. This is passed back into the License Enclave, and the License Enclave uses the License Key to MAC the permit in the licenseMAC field.

The following picture extracted from the patent indicates how an enclave is initialized in presence of a `Launch Enclave`. It is following that the License Key (or Launch Key) for CMAC was derived following the Key Derivation process described in [[1]][sgx-explain].

![My helpful screenshot]({{site.url}}/images/LaunchKey.png)

The Enclave License Structure that is passed to EMKPERMIT seems similar to `SIGSTRUCT` in the latest document. Similarly, `The enclave permit with MAC for CPU and license` seems to represent the `EINITTOKEN` we described above. The whole launching process above can be visuallized as in the picture below:

![My helpful screenshot]({{site.url}}/images/LaunchingEINIT.png)

### EINIT

`EINIT` is the final instruction executed in the enclave build process. After `EINIT`, the `SECS.MRENCLAVE` is complete, fixed and the enclave can execute code using `EENTER`. `EINIT` takes the effective address of a `SIGSTRUCT`, a `EINITTOKEN`, and a `SECS`:

![My helpful screenshot]({{site.url}}/images/EINIT.png)

* `SIGSTRUCT` provides certified information from enclave owner who has business partnership with Intel. Its authenticity is protected by MAC filled in `SIGSTRUCT.SIGNATURE`.

* `EINITTOKEN` provides certified information as the enclave is complied with undocumented `Intel Launch Policy` and is permitted to start. Its integrity is protected by MAC filled in `EINITTOKEN.MAC`. `EINITTOKEN` is a result of negotiation over the cloud [[3]][sgx-patent]. Apparently, only Launch Enclave is able to executed `EGETKEY` to retrieve `Launch Key`.

Either `SIGSTRUCT` or `EINITTOKEN` is invalid would cause `EINIT` to fail. In particular, `EINIT` performs the following checks:

* Validates that `SIGSTRUCT` is signed using the enclosed public key.
* Checks that the completion of `SIGSTRUCT.HASHENCLAVE` = `SECS.MRENCLAVE`
* Checks that no Intel-only bit is set to 1 in `SIGSTRUCT.ATTRIBUTES` unless `SIGSTRUCT` is signed by Intel.
* Verifies if the `EINITTOKEN` was created for this enclave by checking `MRSIGNER` and `MRENCLAVE`. Suppose `EINITTOKEN` does not validate those fields, system software can supply a different `EINITTOKEN` and thus, deviate the enclave's behaviors.

## Practice

The simulated application starts with reading the token file into `token`:

```cpp
FILE *fp = fopen(token_path, "rb");
    if (fp == NULL && (fp = fopen(token_path, "wb")) == NULL) {
        printf("Warning: Failed to create/open the launch token file \"%s\".\n", token_path);
    }

    if (fp != NULL) {
        /* read the token from saved file */
        size_t read_num = fread(token, 1, sizeof(sgx_launch_token_t), fp);
        if (read_num != 0 && read_num != sizeof(sgx_launch_token_t)) {
            /* if token is invalid, clear the buffer */
            memset(&token, 0x0, sizeof(sgx_launch_token_t));
            printf("Warning: Invalid launch token read from \"%s\".\n", token_path);
        }
    }
    /* Step 2: call sgx_create_enclave to initialize an enclave instance */
    /* Debug Support: set 2nd parameter to 1 */
    ret = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, &token, &updated, &global_eid, NULL);
```
 Then, reading the `enclave.signed.so` into handler `fd`, which is an integer value.
```cpp
extern "C" sgx_status_t sgx_create_enclave(const char *file_name, const int debug, sgx_launch_token_t *launch_token, int *launch_token_updated, sgx_enclave_id_t *enclave_id, sgx_misc_attribute_t *misc_attr)
{
    sgx_status_t ret = SGX_SUCCESS;

    //Only true or false is valid
    if(TRUE != debug &&  FALSE != debug)
        return SGX_ERROR_INVALID_PARAMETER;

    // return an integer used to refer to the file
    int fd = open(file_name, O_RDONLY);
    if(-1 == fd)
    {
        SE_TRACE(SE_TRACE_ERROR, "Couldn't open the enclave file, error = %d\n", errno);
        return SGX_ERROR_ENCLAVE_FILE_ACCESS;
    }
    se_file_t file = {NULL, 0, false};
    char resolved_path[PATH_MAX];
    file.name = realpath(file_name, resolved_path);
    file.name_len = (uint32_t)strlen(resolved_path);
    ret = _create_enclave(!!debug, fd, file, NULL, launch_token, launch_token_updated, enclave_id, misc_attr);
    ...

    return ret;
}
```
Afterwards, the file is mapped so that enclave's metadata can be extracted as follows:
```cpp
sgx_status_t _create_enclave(const bool debug, se_file_handle_t pfile, se_file_t& file, le_prd_css_file_t *prd_css_file, sgx_launch_token_t *launch, int *launch_updated, sgx_enclave_id_t *enclave_id, sgx_misc_attribute_t *misc_attr)
{
    unsigned int ret = SGX_SUCCESS;
    sgx_status_t lt_result = SGX_SUCCESS;
    uint32_t file_size = 0;
    map_handle_t* mh = NULL;
    sgx_misc_attribute_t sgx_misc_attr;
    metadata_t *metadata = NULL;
    SGXLaunchToken *lc = NULL;
    memset(&sgx_misc_attr, 0, sizeof(sgx_misc_attribute_t));

    if(NULL == launch || NULL == launch_updated || NULL == enclave_id)
        return SGX_ERROR_INVALID_PARAMETER;
    ...
    mh = map_file(pfile, &file_size);
    if (!mh)
        return SGX_ERROR_OUT_OF_MEMORY;
    PARSER parser(const_cast<uint8_t *>(mh->base_addr), (uint64_t)(file_size));
    ...
    if(SGX_SUCCESS != (ret = get_metadata(&parser, debug,  &metadata, &sgx_misc_attr)))
    {
        goto clean_return;
    }
    ...
    lc = new SGXLaunchToken(&metadata->enclave_css, &sgx_misc_attr.secs_attr, launch);
    lt_result = lc->update_launch_token(false);
    ...
    //Need to set the whole misc_attr instead of just secs_attr.
    do {
        ret = __create_enclave(parser, mh->base_addr, metadata, file, debug, lc, prd_css_file, enclave_id,
                               misc_attr);
        //SGX_ERROR_ENCLAVE_LOST caused by initializing enclave while power transition occurs
    } while(SGX_ERROR_ENCLAVE_LOST == ret);
    ...
  }
```
Tracing through the constructor of `SGXLaunchToken`, it copies launch `token` to `m_launch`. This format is following the `Initialization Lists to Initialize Fields` [[4]][c-programming]

```cpp
linux-sgx/psw/urts/launch_checker.cpp

SGXLaunchToken::SGXLaunchToken(
    const enclave_css_t *css,
    const sgx_attributes_t *secs_attr,
    const sgx_launch_token_t *launch)
    :m_css(css), m_secs_attr(secs_attr), m_launch_updated(false)
{
    memcpy_s(m_launch, sizeof(m_launch), launch, sizeof(m_launch));
}
```
Then, the loader starts to initialize the enclave in `loader.cpp`:

```cpp
linux-sgx/psw/urts/loader.cpp

//initialize Enclave
  ret = get_enclave_creator()->init_enclave(ENCLAVE_ID_IOCTL, const_cast<enclave_css_t *>(&m_metadata->enclave_css), lc, prd_css_file);
  if(SGX_SUCCESS != ret)
  {
      SE_TRACE(SE_TRACE_WARNING, "init_enclave failed\n");
      goto fail;
  }
```

In the above code, we start with retrieve an instance for Simulated Enclave Creator, we sends in the following for the `init_enclave`:

* `ENCLAVE_ID_IOCTL` is an enclave ID
* `m_data->enclave-css` is the `SIGSTRUCT` associate with the enclave ID. `m_data` was filled during the execution at `_create_enclave` by information from `enclave.signed.so`.
* lc is an SGX Launch Token that we read from token file
* `prd_css_file` is a production `SIGSTRUCT` which is linked with `Launch Enclave`. This value is `NULL` as in simulation mode.

Following the trace, we further reconfirm that `prd_css_file` will not be used. The `token` is zeroes-out and launch token is retrieved via `get_launch_token`.

```cpp
linux-sgx/sdk/simulation/urtssim/enclave_creator_sim.cpp

int EnclaveCreatorSim::init_enclave(sgx_enclave_id_t enclave_id, enclave_css_t *enclave_css, SGXLaunchToken *lc, le_prd_css_file_t *prd_css_file)
{

    UNUSED(prd_css_file);
    sgx_launch_token_t token;
    memset(token, 0, sizeof(sgx_launch_token_t));

    int ret = lc->get_launch_token(&token);
    if(ret != SGX_SUCCESS)
        return ret;

    return ::init_enclave(enclave_id, enclave_css, reinterpret_cast<token_t *>(token));
}
```
The launch token is retrieved via `get_launch_token` which simply copy the token from the `m_launch` when we first initialized the `lc`.
```cpp
linux-sgx/psw/urts/launch_checker.cpp

sgx_status_t SGXLaunchToken::get_launch_token(sgx_launch_token_t *tok) const
{
    if (memcpy_s(tok, sizeof(m_launch), &m_launch, sizeof(m_launch)))
        return SGX_ERROR_UNEXPECTED;
    return SGX_SUCCESS;
}
```
Then, ``::init_enclave` will invoke simulation code in `driver_api.cpp`.
```cpp
linux-sgx/sdk/simulation/driver_api/driver_api.cpp

int init_enclave(sgx_enclave_id_t  enclave_id,
                 enclave_css_t     *enclave_css,
                 token_t           *launch)
{
    CEnclaveMngr* mngr = CEnclaveMngr::get_instance();
    CEnclaveSim* ce = mngr->get_enclave(enclave_id);

    if (ce == NULL) {
        SE_TRACE(SE_TRACE_DEBUG,
                 "enclave (id = %llu) not found.\n",
                 enclave_id);
        return SGX_ERROR_INVALID_ENCLAVE_ID;
    }

    return (int)DoEINIT_SW(ce->get_secs(), enclave_css, launch);
}
```
Following by an actual simulated `EINIT` instruction:

```cpp
linux-sgx/sdk/simulation/uinst/u_instructions.cpp

uintptr_t _EINIT(secs_t* secs, enclave_css_t *css, token_t *launch)
{
    CEnclaveMngr *mngr = CEnclaveMngr::get_instance();
    assert(mngr != NULL);

    CEnclaveSim* ce = mngr->get_enclave(secs);
    GP_ON(ce == NULL);

    GP_ON((ce->get_secs()->attributes.flags & SGX_FLAGS_INITTED) != 0);

    // Fill MREnclave, MRSigner, ISVPRODID, ISVSVN
    secs_t* this_secs = ce->get_secs();
    if (css != NULL) {
        // Check signature
        if ((css->body.attribute_mask.xfrm & this_secs->attributes.xfrm)
            != (css->body.attribute_mask.xfrm & css->body.attributes.xfrm))
        {
            SE_TRACE(SE_TRACE_DEBUG,
                "SECS attributes.xfrm does NOT match signature attributes.xfrm\n");
            return SGX_ERROR_INVALID_ATTRIBUTE;
        }

        if ((css->body.attribute_mask.flags & this_secs->attributes.flags)
            != (css->body.attribute_mask.flags & css->body.attributes.flags))
        {
            SE_TRACE(SE_TRACE_DEBUG,
                "SECS attributes.flag does NOT match signature attributes.flag\n");
            return SGX_ERROR_INVALID_ATTRIBUTE;
        }

        mcp_same_size(&this_secs->mr_enclave, &css->body.enclave_hash, sizeof(sgx_measurement_t));
        this_secs->isv_prod_id = css->body.isv_prod_id;
        this_secs->isv_svn = css->body.isv_svn;

        ippsHashMessage(css->key.modulus, SE_KEY_SIZE, (Ipp8u*)&this_secs->mr_signer, IPP_ALG_HASH_SHA256);
    }

    // Check launch token
    if (launch != NULL && launch->body.valid) {
        if (memcmp(&launch->body.attributes, &this_secs->attributes, sizeof(sgx_attributes_t)))
        {
            SE_TRACE(SE_TRACE_DEBUG,
                "SECS attributes does NOT match launch token attribuets\n");
            return SGX_ERROR_INVALID_ATTRIBUTE;
        }
    }

    // Mark it initialized
    this_secs->attributes.flags |= SGX_FLAGS_INITTED;

    return SGX_SUCCESS;
}
```

In conclusion, we can observe the following things in simulation mode:
 * `SIGSTRUCT` was extracted from `enclave.signed.so`.
 * `Launch token` was barely needed. It is followed that the role of `Launch Enclave` is not clear.
 * Enclave's attribute is marked as `INITIALIZED`.
 * There is no `MRSIGNER`.
 * The `lc` object is used to keep track and update the `launch token`
 * Apparently, there is a `launch token`, which is differ from `EINIT token` [[5]][launch-token]. It is followed that the simulated version of `EINIT` only concerns with `launch token`

[sgx-explain]:https://eprint.iacr.org/2016/086.pdf
[sgx-programming]:https://software.intel.com/sites/default/files/managed/48/88/329298-002.pdf
[sgx-patent]:https://www.google.com/patents/WO2011078855A1?cl=en
[c-programming]:https://www.tutorialspoint.com/cplusplus/cpp_constructor_destructor.htm
[launch-token]:https://software.intel.com/pt-br/node/703602
